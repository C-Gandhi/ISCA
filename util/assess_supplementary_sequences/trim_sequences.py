#!/usr/bin/env python3

"""
A script which trims assembled sequences based on a set of reference sequences.
This will not trim the reference sequence at all, but will remove anything
which overhangs on the assembled sequence based on the reference alignment. 
This overhang is to be expected given most assembled sequences as the reads 
used to build the sequence will contain data beyond just the reference sequence. 
This script is built to work specifically with the output of TASR:

https://github.com/warrenlr/TASR 

Input: 
    1. Paths to two FASTA files separated by commas. The first file should be
    the reference file and the second file should be the assembled sequences
    from the TASR run (ends with .contigs).
    2. Path to install directory of EMBOSS needle executable.
    3. Name of the output directory to write to. 

Output: 
    1. A single FASTA file with all the new trimmed sequences.

Usage:
    trim_sequences.py -f fasta1.fsa,fasta2.fsa -n /path/to/emboss/bin/needle -o /path/to/outfile.fsa

Author: 
    James Matsumura
"""

import argparse
import os
from collections import defaultdict
from Bio import SeqIO, AlignIO
from Bio.Seq import Seq
from Bio.Emboss.Applications import NeedleCommandline
from shared_fxns import make_directory,write_fasta


def main():

    parser = argparse.ArgumentParser(description='Script to generate trimmed sequences from an over-assembled set of sequences.')
    parser.add_argument('-f', type=str, required=True, help='Two paths to FASTA files split by a comma.')
    parser.add_argument('-n', type=str, required=True, help='Path to install directory of EMBOSS needle executable (e.g. /path/to/packages/emboss/bin/needle).')
    parser.add_argument('-o', type=str, required=True, help='Location to generate output directories.')
    args = parser.parse_args()

    make_directory(args.o)

    ref_seqs = SeqIO.to_dict(SeqIO.parse(args.f.split(',')[0],"fasta"))
    tasr_seqs = SeqIO.to_dict(SeqIO.parse(args.f.split(',')[1],"fasta"))

    outfile = "{}/trimmed.fsa".format(args.o)

    for key in tasr_seqs:

        id = key.split('|')[0]

        entry1_file = "{}/seq1.fsa".format(args.o)
        entry2_file = "{}/seq2.fsa".format(args.o)
        align_file = "{}/{}_align.txt".format(args.o,id)

        write_fasta(entry1_file,id,str(ref_seqs[id].seq))
        write_fasta(entry2_file,key,str(tasr_seqs[key].seq))

        run_needle(
            args.n,
            entry1_file,
            entry2_file,
            align_file
        )

        a,b = (None for i in range(2))
        alignment = AlignIO.read(align_file,"emboss")

        for sequence in alignment:

            if a == None:
                a = str(sequence.seq)
            else:
                b = str(sequence.seq)

            if a != None and b != None:

                trimmed_seq = trim_extensions(a,b)
                write_fasta(outfile,key,trimmed_seq)

        os.remove(entry1_file)
        os.remove(entry2_file)
        os.remove(align_file)

def build_sequence_map(sequence_ids):
    """ 
    Builds a map of a base sequence to all of its assembled sequences. For 
    example, ABC.123.1 and ABC.123.2 will be mapped by 123 to those two 
    distinct IDs. 

    Args:
        sequence_id_dict (dict_keys): .keys() from SeqIO.to_dict result

    Returns:
        A dict which maps a base ID like 123 to ABC.123.1 and ABC.123.2. All 
        values in this dict will be a list, most will likely be of length 1.
    """
    sequence_map = defaultdict(list)

    for id in sequence_ids:
        sequence_map[id.split('.')[1]].append(id)

    return sequence_map


def run_needle(needle_exe,aseq,bseq,outfile):
    """ 
    Executes the EMBOSS needle program.

    Args:
        needle_exe (str): path to EMBOSS needle executable
        aseq (str): path to first sequence file
        bseq (str): path to second sequence file
        outfile (str): path to the output file to generate
    """
    needle_cline = NeedleCommandline(
        needle_exe,
        asequence=aseq,
        bsequence=bseq,
        gapopen=10,
        gapextend=0.5,
        outfile=outfile
    )

    stdout,stderr = needle_cline()

    return None


def trim_extensions(a,b):
    """ 
    Function to trim the extended blank bases identified from a Needle alignment.
    Note that this trimming just removes the blanks present in the extension on
    the perimeters of the reference locus sequence. If the contig generated by
    the assembler is shorter than the reference, then no adjustment is made and the
    original alignment should be the same as the trimmed alignment. 

    Args:
        a (str): first sequence (reference extracted FASTA)
        b (str): second sequence (assembled sequence)

    Returns:
        Returns the trimmed sequence as a string. 
    """
    aseq = a.replace('-','') # check the length of the actual sequence, no gaps!
    bseq = b.replace('-','')

    """
    Leave early if the assembled sequence is smaller than the reference
    and do not trim.                      ref:      ========
                                          assembled:   ===
    """
    if len(aseq) > len(bseq):
        return bseq

    curr_length = len(a) # length before trimming left

    """
    Trim ONLY the assembled region that fails to align to the ref in a 
    staggered alignment. This can be one of two cases...
    If the sequences overlap like this:   ref:             =========
                                          assembled:   ========    

    Or if the sequences overlap like this:   ref:      ========
                                         assembled:         ========                      
    """
    if ((a[0] == "-" and b[0] != "-") and (a[-1] != "-" and b[-1] == "-")):
        ltrim = 0
        a = a.lstrip('-') 
        ltrim = curr_length - len(a)
        b = b[ltrim:]
        b = b.replace('-','')
        if len(b) == 0: # 0 overlap present, return the sequence as is
            return bseq
        else:
            return b

    elif ((b[0] == "-" and a[0] != "-") and (b[-1] != "-" and a[-1] == "-")):
        rtrim = 0
        a = a.rstrip('-')
        rtrim = (curr_length - len(a)) * -1
        b = b[:rtrim]
        b = b.replace('-','')
        if len(b) == 0: # 0 overlap present, return the sequence as is
            return bseq
        else:
            return b

    """
    If we've made it here, know that the reference likely falls 
    entirely within the assembly. Trim the overextensions from 
    the assembled contig. Another case covered here is when 
    the assembled sequence covers a great deal of the internal 
    region. Thus, while there is no outside to trim, the assembly
    is indeed longer than the reference. While unlikely, it may 
    also be the case where the two are the exact same length. 
                                          ref:         ===
                                          assembled: =======
    """
    l_trim,r_trim = (0 for i in range(2))

    a = a.lstrip('-')
    if curr_length != len(a):
        l_trim = curr_length - len(a)

    curr_length = len(a) # length before trimming right  

    a = a.rstrip('-') 
    if curr_length != len(a):
        r_trim = (curr_length - len(a)) * -1
    else: # don't trim! go all the way to the end of the seq
        r_trim = len(b)

    """
    If it's the case where the assembly fills in the internal regions,
    meaning the reference is full of gaps but matches on the ends, make
    sure not to do a subset of [0:0] for b.     
    """
    if l_trim == 0 and r_trim == 0:
        pass
    else:
        b = b[l_trim:r_trim]

    b = b.replace('-','')

    return b


if __name__ == '__main__':
    main()