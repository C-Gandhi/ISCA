

# This script follows extract_sequences.py+final_verdict.py and reports 
# stats on overall GC content, exon GC, intron GC, max intron length,
# overall gene length, length after splicing, best ID achieved by the pipeline,
# and the gene name provided in the GFF3 file. It calculates intron AT content 
# by pooling together all the introns and considers those one long sequence
# where it calculates AT content of that sequence.
#
# Note that this expects an intron map and sequences from just one reference 
# since we expect only one to be annotated well. For Plasmodium, use the
# original GFF3 and the FASTA+intron map files generated by extract_sequences.py
#
# Run the script using a command like this:
# python3 generate_overview.py -intron_map intron_map -seqs seqs.fsa -gff3 ref.gff3 -prefix 3D7 -final_verdict_map ivc.tsv -outfile output
#
# Author: James Matsumura

import re,argparse
from Bio import SeqIO
from Bio.SeqUtils import GC
from urllib.parse import unquote_plus

def main():

    parser = argparse.ArgumentParser(description='Script to assess the results of the base Targeted Assembly pipeline.')
    parser.add_argument('-intron_map', type=str, required=True, help='Path to intron map generated by extract_sequences.py.')
    parser.add_argument('-seqs', type=str, required=True, help='FASTA file that corresponds to the introns in the map.')
    parser.add_argument('-prefix', type=str, required=True, help='Prefix for the FASTA sequences to refer to (use the best annotated reference).')
    parser.add_argument('-gff3', type=str, required=True, help='Path to GFF3 file to get gene names from.')
    parser.add_argument('-min_intron_length', type=int, default=0, required=False, help='Min length of intron to keep in output.')
    parser.add_argument('-final_verdict_map', type=str, required=True, help='Map derived from the final verdict script.')
    parser.add_argument('-outfile', type=str, required=True, help='Path to where the unaligned/unassembled FASTA entries and the new alignments map should go.')
    args = parser.parse_args()

    seq_dict = SeqIO.to_dict(SeqIO.parse(args.seqs,"fasta"))
    best_id,gff3_dict = ({} for i in range(2))
    has_intron = set()

    regex_for_name = r'.*Name=([a-zA-Z0-9_\.\-]+)'
    regex_for_description = r'description=(.*)'

    with open(args.gff3,'r') as gff3:
        for line in gff3:
            if line.startswith('##FASTA'): # don't care about sequences
                break
            elif line.startswith('#'): # don't care about comments or header data
                pass
            else: # within the GFF3 9-column section
                ele = line.split('\t')
                if ele[2] == 'gene': # only process if it is a gene
                    # Description is messy as it has some odd encoding
                    isolate_description = ele[8].split(';')
                    description,id = ("" for i in range(2))
                    for attr in isolate_description:
                        if attr.startswith('description'):
                            description = unquote_plus(re.search(regex_for_description,attr).group(1))

                    id = re.search(regex_for_name,ele[8]).group(1) # extract the name from attr that links via GMAP
                    gff3_dict[id] = description

    with open(args.final_verdict_map,'r') as fvm:
        for line in fvm:
            result = line.strip().split('\t')
            regex_for_locus = r'/([a-zA-Z0-9\_\.]+).txt'
            locus = re.search(regex_for_locus,result[3]).group(1).split('.')[1]
            id = 0
            if len(result) == 5:
                id = result[4]
            else:
                id = result[0]
            if locus in best_id:
                if float(id) > float(best_id[locus]):
                    best_id[locus] = id
            else:
                best_id[locus] = id

    with open(args.intron_map,'r') as im:
        with open(args.outfile,'w') as out:
            out.write("locus\tbest_id\toverall_gc\texon_gc\tintron_gc\tmax_intron_length\tgene_length\tlength_after_splicing\tgene_description\n")
            for line in im:
                elements = line.strip().split("\t")

                # already re-oriented these in extract_alleles.py
                locus = "{0}.{1}".format(args.prefix,elements[0])
                mapped_locus = locus.split('.')[1]
                start_pos = elements[1]
                exons = elements[3:len(elements)]
                max_intron_length = int(elements[2])

                if args.min_intron_length:
                    if max_intron_length < args.min_intron_length:
                        continue

                intron_stats = calculate_intron_content(start_pos,seq_dict[locus].seq,exons)
                exon_only = calculate_exon_content(start_pos,seq_dict[locus].seq,exons)
                seq_len = len(seq_dict[locus].seq)
                exon_only_length = int(seq_len) - int(intron_stats[0])
                id = "0"
                if mapped_locus in best_id:
                    id = best_id[mapped_locus]
                    has_intron.add(mapped_locus)
                
                out.write("{0}\t{1}\t{2:.4f}\t{3:.4f}\t{4:.4f}\t{5}\t{6}\t{7}\t{8}\n".format(elements[0],id,GC(seq_dict[locus].seq),exon_only,intron_stats[1],max_intron_length,seq_len,exon_only_length,gff3_dict[elements[0]]))

            # Get all the genes that don't have introns
            for locus in seq_dict:
                mapped_locus = locus.split('.')[1]
                unmapped_locus = locus.split('.',1)[1]
                if mapped_locus in has_intron:
                    continue
                else:
                    seq_len = len(seq_dict[locus].seq)
                    out.write("{0}\t{1}\t{2:.4f}\t{3:.4f}\t{4}\t{5}\t{6}\t{7}\t{8}\n".format(mapped_locus,best_id[mapped_locus],GC(seq_dict[locus].seq),exon_only,"NA","NA",seq_len,seq_len,gff3_dict[unmapped_locus]))

# Feed this the start_pos/offset for the intron positions and the sequence
# to pull introns from and it gives back GC content for just the intronic 
# sequences.
def calculate_intron_content(start_pos,seq,exons):

    intron_seq = ""

    for j in range(0,len(exons)-1):
        exon1_end = int(exons[j].split(':')[1]) - int(start_pos)
        exon2_sta = int(exons[j+1].split(':')[0]) - int(start_pos)

        intron_seq += seq[exon1_end:exon2_sta]

    intron_details = []
    intron_details.append(len(intron_seq))
    intron_details.append(GC(intron_seq))
    return intron_details

def calculate_exon_content(start_pos,seq,exons):

    exon_seq = ""

    for exon in exons:
        sta = int(exon.split(':')[0]) - int(start_pos)
        end = int(exon.split(':')[1]) - int(start_pos)

        exon_seq += seq[sta:end]

    return GC(exon_seq)

if __name__ == '__main__':
    main()