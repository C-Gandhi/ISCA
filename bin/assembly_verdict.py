#!/usr/bin/env python3

"""
This script follows threaded_assess_alignment.py. This is only necessary
to run if there are still sequences that have yet to be assembled at an 
adequate threshold. The input is the ids_v_cov.tsv file from the end
of the pipeline, the ORIGINAL FASTA file generated, and the output map 
from format_for_assembly.py. It also requires a minimum threshold for 
those %ID of the new assembled sequences to have aligned at. This means 
if you give it a value of 80 then only %ID alignments from assemblies 
less than 80 will be put into the next round of reference sequences. 

Note that beyond the second round of reconstruction you must concatenate 
all ids_v_cov.tsv files from previous runs in order to make sure to not
include a locus that has already been assembled well enough. 

    Input:
        1. Path to ids_v_cov.tsv from threaded_assess_alignment.py
        2. Threshold of percent identity achieved in alignment for the assembly 
        to be considered a success/failure
        3. Path to the buffered FASTA sequences generated by extract_sequences.py 
        4. Path to the previous assmb_map.tsv generated by format_for_assembly.py
        5. Name of the prefix for the various output files

    Output:
        1. prefix_leftovers.fasta
        All sequences which were unable to assemble, can be used to try a new
        set of alignment/assembly steps.
        2. prefix_new_assmb_map.tsv
        A new assembly map to allow re-use of the same directories already built
        for assembling these sequences. 

    Usage:
        assembly_verdict.py --ivc /path/to/ids_v_cov.tsv --threshold 80 --original_assmb_map /path/to/assmb_map.tsv --original_buffered_fsa /path/to/old.fsa --prefix /path/to/my_prefix

    Author: 
        James Matsumura
"""

import re,argparse
from shared_fxns import write_fasta

def main():

    parser = argparse.ArgumentParser(description='Script to assess the results of the base Targeted Assembly pipeline.')
    parser.add_argument('--ivc', '-i', type=str, required=True, help='Path to an ids_v_cov.tsv file from the previous run.')
    parser.add_argument('--threshold', '-t', type=float, required=True, help='Minimum threshold of %ID that needs to be met to pass final assembly.')
    parser.add_argument('--original_buffered_fsa', '-of', type=str, required=True, help='Path to where the buffered (buffer may be 0 so this will be same as unbuffered) FASTA from extract_sequences.py is.')
    parser.add_argument('--original_assmb_map', '-oam', type=str, required=True, help='Path to where the output from format_for_assembly.py is located.')
    parser.add_argument('--prefix', '-p', type=str, required=True, help='Name of the prefix for the various output files.')
    args = parser.parse_args()

    assembled,aligned = (set() for i in range(2))
    regex_for_locus = r'/([a-zA-Z0-9\_\.]+).txt'

    # Iterate over the ids_v_cov.tsv file and find those loci which were
    # ABLE to assemble at the minimum threshold. Note that it needs to be
    # done in this manner since not every locus from the original set
    # may have even produced alignments from the recruiter.  
    with open(args.ivc,'r') as i:
        for line in i:
            line = line.rstrip()
            result = line.split('\t') 

            filename = re.search(regex_for_locus,result[3]).group(1)
            locus = filename.split('.')[1]

            percent_id = result[0]

            # If we are using the assessment results from scaffold builder, 
            # get the reference % ID to exclude gaps
            if len(result) == 5:
                percent_id = result[4]

            # First check if this sequence passed the minimum threshold
            if float(percent_id) >= args.threshold:

                # Know that the locus is the second group of the alignment.txt
                # file split by periods
                assembled.add(locus)
                aligned.add(locus)
            
            else:
                aligned.add(locus)

    leftovers = "{0}_leftovers.fasta".format(args.prefix)
    extract_sequences(args.original_buffered_fsa,assembled,aligned,leftovers)

    new_assmb_map = "{0}_new_assmb_map.tsv".format(args.prefix)
    new_id = 1 # start a counter for new SGE ID for this assembly
    with open(new_assmb_map,'w') as o:
        with open(args.original_assmb_map,'r') as i:
            for line in i:
                line = line.rstrip()
                elements = line.split('\t')
                locus = elements[0]
                sge_id = elements[1]
                if locus not in assembled:
                    o.write("{0}\t{1}\t{2}\n".format(locus,sge_id,new_id))
                    new_id += 1


# Arguments:
# file = FASTA file
# assembled = set of loci that are already assembled well enough.  
# aligned = set of loci that at least aligned and tried to assemble.
# outfile = both contents of outfile1 and outfile2
def extract_sequences(file,assembled,aligned,outfile):

    regex_for_contig_id = ">([a-zA-Z0-9_\.]+)"

    # Since PF is fairly small, can be greedy about how the FASTA entries are being
    # processed and store them in memory.
    contigs = {}
    not_assembled,not_aligned = ([] for i in range(2)) # note which IDs should be re-added at the end
    current_id = "" # store the previous key for the bases to be assigned to

    with open(file,'r') as fasta:
        for line in fasta: # iterate over the FASTA file and extract the entirety of each sequence
            
            line = line.rstrip()

            if line.startswith('>'):

                current_id = re.search(regex_for_contig_id,line).group(1)
                contigs[current_id] = ""

                # in addition to grabbing entire header, check if this entry is needed later
                locus = line.split('.')[1] 
                if locus not in aligned: # we know that if it didn't align, couldn't have assembled
                    not_aligned.append(current_id)
                elif locus not in assembled:
                    not_assembled.append(current_id)

            else:
                contigs[current_id] += line # add all the bases

    for allele in not_assembled:
        write_fasta(outfile,allele,contigs[allele])

    for allele in not_aligned:
        write_fasta(outfile,allele,contigs[allele])


if __name__ == '__main__':
    main()