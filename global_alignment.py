

# This script uses EMBOSS's needle global alignment tool to perform alignments
# between the assembled output of format_for_spades.py+SPAdes and the initial 
# FASTA set used to build the Bowtie2 reference.  
#
# Run the script using a command like this:
# python3 global_alignment.py -i /path/to/spades_map.tsv -f /path/to/ref.fasta -out /path/to/alignment_out
#
# Author: James Matsumura

import sys,re,argparse,os
from collections import defaultdict
from Bio.Emboss.Applications import NeedleCommandline
from Bio import AlignIO
from Bio import SeqIO

def main():

    parser = argparse.ArgumentParser(description='Script to generate EMBOSS Needle alignments given output from format_for_spades.py.')
    parser.add_argument('-ea_map', type=str, required=True, help='Path to map.tsv output from extract_alleles.py.')
    parser.add_argument('-ffs_map', type=str, required=True, help='Path to map.tsv output from format_for_spades.py.')
    parser.add_argument('-ref_genome', type=str, required=True, help='Path to the reference genome file used to build Bowtie2 index.')
    parser.add_argument('-assmb_path', type=str, required=True, help='Path to the the directory preceding all the ref directories (e.g. for "/path/to/ref123" put "/path/to" as the input).')
    parser.add_argument('-out', type=str, required=True, help='Path to output directory for all these alignments.')
    args = parser.parse_args()

    # First, extract the sequences from the reference file and 
    # *STORE IN MEMORY* (careful how big the reference genome used is.
    # We need this to generate small FASTA files for Needle alignment. 
    seq_dict = SeqIO.to_dict(SeqIO.parse(args.ref_genome,"fasta"))

    # In order to access these seqs efficiently, rebuild the DS created 
    # in extract_alleles.py. This is a dictionary where the key is the 
    # shared locus and the value is a list of all the mapped alleles. 
    ref_dict = defaultdict(list)
    with open(args.ea_map,'r') as loc_map:

        for line in loc_map:
            line = line.rstrip()
            ele = line.split('\t')
            locus = ele[0]

            for j in range(1,len(ele)):
                allele_info = ele[j].split('|')
                allele = allele_info[4]
                ref_dict[locus].append(allele)

    # Now that we can easily extract the sequences for alignment, iterate over
    # the directory name map file and perform alignments. 
    with open(args.ffs_map,'r') as dir_map:

        for line in dir_map:
            line = line.rstrip()
            ele = line.split('\t')
            locus = ele[0]
            loc_dir = ele[1]
            bseq_file = "{0}/{1}/contigs.fasta".format(args.assmb_path,loc_dir)
            out_dir = "{0}/{1}".format(args.out,locus)
            os.makedirs(out_dir)

            for ref_seq in ref_dict[locus]:
                seq = seq_dict[ref_seq]
                aseq_file = "{0}/{1}.fsa".format(out_dir,ref_seq)
                with open(aseq_file,'w') as fsa:
                    SeqIO.write(seq,fsa,"fasta")

                # Now have the reference FASTA file, perform alignment
                # with the assembled contig.
                align(out_dir,ref_seq,aseq_file,bseq_file)


# Function to perform an alignment between the reference FASTA sequence and
# the SPAdes contig assembled. 
# Arguments:
# out = output directory for this script
# allele = name of the allele used in the alignment
# aseq = newly generated FASTA file extracted from this script
# bseq = location of the contig.fasta file generated by SPAdes
def align(out,allele,aseq,bseq):

    needle_exe = r"/usr/local/packages/EMBOSS-6.3.1/bin/needle" # path to EMBOSS Needle executable
    format = "emboss"

    initial_align = "{0}/{1}.align.txt".format(out,allele)

    needle = NeedleCommandline(needle_exe,
                                asequence=aseq,
                                bsequence=bseq,
                                gapopen=10,gapextend=0.5,outfile=initial_align)
    stdout,stderr = needle()

    a,b = (None for i in range(2))

    for alignment in AlignIO.parse(initial_align,format):
        for sequence in alignment:

            if a == None: # grab both sequences, first being the reference seq
                a = sequence.seq
            else: # now grab the assembled seq
                b = sequence.seq            

            # Once two sequences are extracted, refine and align trimming the 
            # outside extended blank sequence.  
            if a != None and b != None:
                refined_align = "{0}/{1}.trimmed_align.txt".format(out,allele)
                a_fsa = "{0}/{1}.a.fsa".format(out,allele)
                b_fsa = "{0}/{1}.b.fsa".format(out,allele)

                seqs = trim_extensions(a,b)
                write_fasta(a_fsa,'a.trimmed',seqs['a'])
                write_fasta(b_fsa,'b.trimmed',seqs['b'])

                needle = NeedleCommandline(needle_exe,
                                asequence=a_fsa,
                                bsequence=b_fsa,
                                gapopen=10, gapextend=0.5,outfile=refined_align)
                stdout,stderr = needle()

# Function to trim the extended blank bases identified from a Needle alignment.
# Note that this trimming just removes the blanks present in the extension on
# the perimeters of the sequence. 
# Arguments:
# a = first sequence (reference extracted FASTA)
# b = second sequence (SPAdes assembled sequence)
def trim_extensions(a,b):

    a = str(a)
    b = str(b)
    curr_length = len(a) # length before trimming left
    a = a.lstrip('-')
    l_trim = curr_length - len(a)

    curr_length = len(a) # length before trimming right    
    a = a.rstrip('-')
    r_trim = (curr_length - len(a)) * -1

    b = b[l_trim:r_trim]
    a = a.replace('-','') # remove embedded gaps, let Needle re-add
    return {'a':a , 'b':b}

# Function to generate new FASTA files after trimming extensions.
# Arguments:
# file: name/path of file to be written
# header: header ID
# seq: sequence to be written
def write_fasta(file,header,seq):
    with open(file,'w') as out:
        out.write(">{0}\n".format(header))
        for j in range(0, len(seq), 60):
            out.write(seq[j:j+60] + "\n")


if __name__ == '__main__':
    main()
